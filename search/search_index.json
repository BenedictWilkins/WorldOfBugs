{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Paper Github World of Bugs (WOB) is a platform that supports research in Automated Bug Detection (ABD) in video games. What is Automated Bug Detection (ABD)? Anyone who has played a game has encountered a bug at some point and probably knows that they come in all shapes and sizes. During development, the development and Quality Assurance (QA) teams take costly steps to try and prevent bugs from making it to release. Many different strategies are used, ranging from Unit Testing to Functional Testing , some of which can be (at least partially) automated. Modern ABD attempts to automated aspects of functional testing, which typically includes playing the game. However it may also appears when performing Regression Testing , or in any other strategy that would otherwise involve significant investment of time dedicated to actually playing the game. Automated Game Playing A large part of ABD involves devising systems that can automatically play and explore video game just like a human game tester would. An automated game player is referred to as an agent . These game playing agents takes actions in the game environment in the same way that a human would using a virtual \"gamepad\" and observe what happens, and taking subsequent actions in order to achieve a predefined goal. Perhaps unsurprisingly developing game playing agents can be very difficult. Games are often made to present some challenge to the player with a variety of obstacles, puzzles and enemies. Only in the last few years have agents been able to play with any video games with any real skill. Early attempts at playing Atari 2600 games with deep reinforcement learning started a trend in researchers attempting to tackle ever more complex games. More recently progress has been made on games that are widely recognised as requiring significant skill such as Dota2 and Starcraft . These systems still require an unrealistic amount of resources to be practical for testing video games, nevertheless they are perhaps an early indication that ABD may form part of the standard toolkit for video game testing in the not so far future. In the majority of research into automated game playing, an agent has a goal, usually to win. In the Atari 2600 example, the goal is specified using a reward that is derived from the in-game score. For ABD however, what is the goal? and more importantly, how should it be specified? At a high level, the goal is to explore the game to find bugs. The agent should have good coverage , meaning that it should explore as much of the game as possible, visit all the areas, complete all the levels, fight all the enemies etc. We might think of the agent as the most eager completionist. Not only does it want to find all the collectables, but also see everything there is to see. In this sense, the agent is a game player of the most hardcore variety. The question of how to specify the goal of such an agent is an open one. Placing this question aside for a moment in favour of a more immediate problem, how is an agent to know that is has encountered a bug on its travels through its favourite game? This is the problem of bug identification. Automated Bug Identification The second facet to the problem of ABD is that of bug identification. When a human tester encounters a bug, how to they know? It could just be some wacky game mechanic, perhaps horses are supposed to do handstands. The waters become a murky around this point. We might formally say that a human tester has a specification that they work from, that explicitly states \"horses don't do handstands\". But for people who have worked in game dev, we know this isn't the case. TO BE CONTINUED...","title":"Home"},{"location":"#home","text":"Paper Github World of Bugs (WOB) is a platform that supports research in Automated Bug Detection (ABD) in video games.","title":"Home"},{"location":"#what-is-automated-bug-detection-abd","text":"Anyone who has played a game has encountered a bug at some point and probably knows that they come in all shapes and sizes. During development, the development and Quality Assurance (QA) teams take costly steps to try and prevent bugs from making it to release. Many different strategies are used, ranging from Unit Testing to Functional Testing , some of which can be (at least partially) automated. Modern ABD attempts to automated aspects of functional testing, which typically includes playing the game. However it may also appears when performing Regression Testing , or in any other strategy that would otherwise involve significant investment of time dedicated to actually playing the game.","title":"What is Automated Bug Detection (ABD)?"},{"location":"#automated-game-playing","text":"A large part of ABD involves devising systems that can automatically play and explore video game just like a human game tester would. An automated game player is referred to as an agent . These game playing agents takes actions in the game environment in the same way that a human would using a virtual \"gamepad\" and observe what happens, and taking subsequent actions in order to achieve a predefined goal. Perhaps unsurprisingly developing game playing agents can be very difficult. Games are often made to present some challenge to the player with a variety of obstacles, puzzles and enemies. Only in the last few years have agents been able to play with any video games with any real skill. Early attempts at playing Atari 2600 games with deep reinforcement learning started a trend in researchers attempting to tackle ever more complex games. More recently progress has been made on games that are widely recognised as requiring significant skill such as Dota2 and Starcraft . These systems still require an unrealistic amount of resources to be practical for testing video games, nevertheless they are perhaps an early indication that ABD may form part of the standard toolkit for video game testing in the not so far future. In the majority of research into automated game playing, an agent has a goal, usually to win. In the Atari 2600 example, the goal is specified using a reward that is derived from the in-game score. For ABD however, what is the goal? and more importantly, how should it be specified? At a high level, the goal is to explore the game to find bugs. The agent should have good coverage , meaning that it should explore as much of the game as possible, visit all the areas, complete all the levels, fight all the enemies etc. We might think of the agent as the most eager completionist. Not only does it want to find all the collectables, but also see everything there is to see. In this sense, the agent is a game player of the most hardcore variety. The question of how to specify the goal of such an agent is an open one. Placing this question aside for a moment in favour of a more immediate problem, how is an agent to know that is has encountered a bug on its travels through its favourite game? This is the problem of bug identification.","title":"Automated Game Playing"},{"location":"#automated-bug-identification","text":"The second facet to the problem of ABD is that of bug identification. When a human tester encounters a bug, how to they know? It could just be some wacky game mechanic, perhaps horses are supposed to do handstands. The waters become a murky around this point. We might formally say that a human tester has a specification that they work from, that explicitly states \"horses don't do handstands\". But for people who have worked in game dev, we know this isn't the case. TO BE CONTINUED...","title":"Automated Bug Identification"},{"location":"Developing%20Worlds/Agents/","text":"Agents Structure of an Agent The default structure of an agent is derived from Unity's MLAgents package abstractions, including ISensor, IActuator, and Agent. Actions and Observations The WOB Python API is the same whether using a standalone build or the unity editor. WOB follows OpenAI Gym for a single agent with some extras to help set up environments in Unity. The step method of the environment is where actions are taken and observations are collected, its usage looks as follows. {{< card-code lang=\"Python\">}} observation, reward, done, info = env.step(action) {{< /card-code >}} The observation contains visual data","title":"Agents"},{"location":"Developing%20Worlds/Agents/#agents","text":"","title":"Agents"},{"location":"Developing%20Worlds/Agents/#structure-of-an-agent","text":"The default structure of an agent is derived from Unity's MLAgents package abstractions, including ISensor, IActuator, and Agent.","title":"Structure of an Agent"},{"location":"Developing%20Worlds/Agents/#actions-and-observations","text":"The WOB Python API is the same whether using a standalone build or the unity editor. WOB follows OpenAI Gym for a single agent with some extras to help set up environments in Unity. The step method of the environment is where actions are taken and observations are collected, its usage looks as follows. {{< card-code lang=\"Python\">}} observation, reward, done, info = env.step(action) {{< /card-code >}} The observation contains visual data","title":"Actions and Observations"},{"location":"Developing%20Worlds/Bugs/Perceptual/","text":"","title":"Perceptual"},{"location":"Examples/","text":"Examples A collection of examples, more coming soon!","title":"Examples"},{"location":"Examples/#examples","text":"A collection of examples, more coming soon!","title":"Examples"},{"location":"Examples/World-v1/","text":"World-v1 World-v1 is an example environment build with WOB, it was used to perform initial experiments in this paper . DETAILS COMING SOON","title":"World-v1"},{"location":"Examples/World-v1/#world-v1","text":"World-v1 is an example environment build with WOB, it was used to perform initial experiments in this paper . DETAILS COMING SOON","title":"World-v1"},{"location":"GettingStarted/","text":"Quick Start Clone the github repository: git clone https://github.com/BenedictWilkins/world-of-bugs.git While in the same directory, install with: python -m pip install world-of-bugs From here there are two options: use a standalone build, or use the unity editor. If you want to use the unity editor, skip to the next section . Getting Started With Standalone Builds Download the latest build for your system here . Extract the build files to a directory of your choice, for example ~/Downloads/builds/Standalone-Linux-World-v1 . To run with the default build settings: # add downloaded builds to path worldofbugs.utils.BuildResolver.path += \"~/Downloads/builds/\" print(worldofbugs.utils.BuildResolver.path) # list all search paths print(worldofbugs.utils.BuildResolver.builds) # list all avaliable environments # make the environment env = worldofbugs.make('WoB/World-v1') env.reset() for i in range(1000): # advance simulation 1000 steps env.step(env.action_space.sample()) # take a random action env.render() #render the game screen, requires pygame installation If everything worked correctly you should see a build printout like: [~/Downloads/builds/Standalone-Linux-World-v1/World-v1.x86_64] and if you have pygame installed ( pip install pygame ) something like the following should appear in your pygame window. You may also notice that a small Unity window popped up, unfortunately this is required to ensure the agent's observations are correctly processed by GPU, see here for details. Build Search When searching for builds the BuildResolver will search one directory deep. The typical directory structure should look something like the following: builds \u2514\u2500\u2500 World-v1 \u251c\u2500\u2500 LinuxPlayer_s.debug \u251c\u2500\u2500 UnityPlayer_s.debug \u251c\u2500\u2500 UnityPlayer.so \u251c\u2500\u2500 World-v1_Data \u2514\u2500\u2500 World-v1.x86_64 with builds being the directory added to BuildResolver.path as above. By default the current working directory and the build directory in the worldofbugs install directory will also be searched. Getting Started with Unity Rather than using a standalone build, it is also possible to connect directly to the Unity editor. This requires the WOB project to be open in unity. To avoid issues, install Unity version 2020.3.25f1 which can be found in the unity download archive using the latest version of UnityHub . Once installed, locate the UnityProject folder in your worldofbugs install directory, add it as a new project in UnityHub and open it in the editor. To connect to the editor, run the following script and then press the play button in the editor window. import worldofbugs # make the environment, None indicates we want to connect to the editor env = worldofbugs.make(None) env.reset() for i in range(1000): # advance simulation 1000 steps env.step(env.action_space.sample()) # take a random action, this will happen in the editor You should see the agent (white sphere) start to move around the level in the scene view, or a message like the one below in the game view. By default, the game view is not rendered as no cameras are in use. To look through the eyes of the agent, in the Unity editor go to Window -> Preview -> RenderTextureCameraPreview . The game view can be safely closed in favour of this new view.","title":"Quick Start"},{"location":"GettingStarted/#quick-start","text":"Clone the github repository: git clone https://github.com/BenedictWilkins/world-of-bugs.git While in the same directory, install with: python -m pip install world-of-bugs From here there are two options: use a standalone build, or use the unity editor. If you want to use the unity editor, skip to the next section .","title":"Quick Start"},{"location":"GettingStarted/#getting-started-with-standalone-builds","text":"Download the latest build for your system here . Extract the build files to a directory of your choice, for example ~/Downloads/builds/Standalone-Linux-World-v1 . To run with the default build settings: # add downloaded builds to path worldofbugs.utils.BuildResolver.path += \"~/Downloads/builds/\" print(worldofbugs.utils.BuildResolver.path) # list all search paths print(worldofbugs.utils.BuildResolver.builds) # list all avaliable environments # make the environment env = worldofbugs.make('WoB/World-v1') env.reset() for i in range(1000): # advance simulation 1000 steps env.step(env.action_space.sample()) # take a random action env.render() #render the game screen, requires pygame installation If everything worked correctly you should see a build printout like: [~/Downloads/builds/Standalone-Linux-World-v1/World-v1.x86_64] and if you have pygame installed ( pip install pygame ) something like the following should appear in your pygame window. You may also notice that a small Unity window popped up, unfortunately this is required to ensure the agent's observations are correctly processed by GPU, see here for details.","title":"Getting Started With Standalone Builds"},{"location":"GettingStarted/#build-search","text":"When searching for builds the BuildResolver will search one directory deep. The typical directory structure should look something like the following: builds \u2514\u2500\u2500 World-v1 \u251c\u2500\u2500 LinuxPlayer_s.debug \u251c\u2500\u2500 UnityPlayer_s.debug \u251c\u2500\u2500 UnityPlayer.so \u251c\u2500\u2500 World-v1_Data \u2514\u2500\u2500 World-v1.x86_64 with builds being the directory added to BuildResolver.path as above. By default the current working directory and the build directory in the worldofbugs install directory will also be searched.","title":"Build Search"},{"location":"GettingStarted/#getting-started-with-unity","text":"Rather than using a standalone build, it is also possible to connect directly to the Unity editor. This requires the WOB project to be open in unity. To avoid issues, install Unity version 2020.3.25f1 which can be found in the unity download archive using the latest version of UnityHub . Once installed, locate the UnityProject folder in your worldofbugs install directory, add it as a new project in UnityHub and open it in the editor. To connect to the editor, run the following script and then press the play button in the editor window. import worldofbugs # make the environment, None indicates we want to connect to the editor env = worldofbugs.make(None) env.reset() for i in range(1000): # advance simulation 1000 steps env.step(env.action_space.sample()) # take a random action, this will happen in the editor You should see the agent (white sphere) start to move around the level in the scene view, or a message like the one below in the game view. By default, the game view is not rendered as no cameras are in use. To look through the eyes of the agent, in the Unity editor go to Window -> Preview -> RenderTextureCameraPreview . The game view can be safely closed in favour of this new view.","title":"Getting Started with Unity"},{"location":"GettingStarted/Live%20Configuration/_index/","text":"An environment can be configured using the WOB environment API . Configuring Bugs A bug can be enabled using the enable_bug method, for example: env.enable_bug(\"MissingTexture\") A bug can be disabled using the disable_bug method, for example: env.disable_bug(\"TextureCorruption\") Bugs names a derived from their type name as it appears in Unity, a full list of bugs can be found Configuring Agent Behaviour An agents behvaiour can be changed using the set_agent_behaviour , for example: env.set_agent_behaviour(\"Manual\") . Setting the agents behaviour will enable heuristic mode. In this mode, actions will be selected by the given Unity script rather than by Python, i.e. the action in env.step(action) will be ignored. Advanced MORE INFO COMING SOON Logging By default all messages logged with Unity's default logging system, Debug.Log are also displayed in the Python console. MORE INFO COMING SOON","title":" index"},{"location":"GettingStarted/Live%20Configuration/_index/#configuring-bugs","text":"A bug can be enabled using the enable_bug method, for example: env.enable_bug(\"MissingTexture\") A bug can be disabled using the disable_bug method, for example: env.disable_bug(\"TextureCorruption\") Bugs names a derived from their type name as it appears in Unity, a full list of bugs can be found","title":"Configuring Bugs"},{"location":"GettingStarted/Live%20Configuration/_index/#configuring-agent-behaviour","text":"An agents behvaiour can be changed using the set_agent_behaviour , for example: env.set_agent_behaviour(\"Manual\") . Setting the agents behaviour will enable heuristic mode. In this mode, actions will be selected by the given Unity script rather than by Python, i.e. the action in env.step(action) will be ignored.","title":"Configuring Agent Behaviour"},{"location":"GettingStarted/Live%20Configuration/_index/#advanced","text":"MORE INFO COMING SOON","title":"Advanced"},{"location":"GettingStarted/Live%20Configuration/_index/#logging","text":"By default all messages logged with Unity's default logging system, Debug.Log are also displayed in the Python console. MORE INFO COMING SOON","title":"Logging"}]}